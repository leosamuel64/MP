Hello - from /home/leo/.vscode-server/extensions/jaredly.reason-vscode-1.7.13/bin.native.linux
Previous log location: /tmp/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml","languageId":"ocaml","version":1,"text":"(* exercice 1 *)\n\ntype graphe1 = int array array;;\ntype graphe2 = int list array;; \n\nlet exemple_mat = [|  [|0;1;0;0|];\n                      [|0;0;1;0|];\n                      [|0;0;0;1|];\n                      [|1;0;0;0|]\n|];;\n\nlet exemple_tab = [|[1];[2];[3];[0]|];;\n\n(* Exercice 1 *)\n\n(* 1 *)\n\nlet compte_Matrice m=\n  let res = ref 0 in\n  for i=0 to Array.length m-1 do\n    for j=0 to Array.length m-1 do\n      if m.(i).(j) = 1 then\n        res:=!res+1\n    done;\n  done;\n  !res\n;;\n\ncompte_Matrice exemple_mat;;\n\nlet compte_liste t=\n  let res=ref 0 in\n  for i=0 to Array.length t-1 do\n    res:=!res+ List.length t.(i)\n  done;\n  !res\n;;\n\ncompte_liste exemple_tab;;\n\n\n(* Pour Samedi : questions 2,3 *)\n\n(* 2 *)\nlet tableau_i n i=\n\tlet res = Array.make n 1 in\n\tfor j = 0 to n-1 do\n\t\tif i=j then\n\t\t\tres.(j) <- 0\n  done;\n  res\n;;\n\t\nlet clique_mat n=\n\tlet res = Array.make n [||] in\n\tfor i=0 to n-1 do\n\t\tres.(i) <- tableau_i n i\n\tdone;\n\tres\n;;\n\nclique_mat 2;;\n\n\t\nlet rec liste_sans_i i n=\n\tmatch n with\n\t|0 -> []\n\t|t when i <> t -> t::(liste_sans_i i (t-1))\n\t|t -> liste_sans_i i (t-1)\n;;\n\t\nlet rec clique_tab n=\n\tlet res = (Array.make n [] ) in\n\tfor i=0 to n-1 do\n\t\tres.(i) <- liste_sans_i (i+1) n\n\tdone;\n\tres\n;;\n\nclique_tab 4;;\t\n\t\n\t\n(* 3 *)\nlet chemin_mat l g=\n\tlet res = ref true in\n\tfor i=0 to Array.length l -2 do\n\t\tif g.(l.(i)).(l.(i+1)) = 0 then\n\t\t\tres := false\n\tdone;\n\t!res\n;;\n\nchemin_mat [|1;2;3|] exemple_mat;;\n\nlet rec appartient x l=\n\tmatch l with\n\t|[] -> false\n\t|t::q when t = x -> true\n\t|t::q -> appartient x q\n;;\n\nlet rec chemin_tab l g=\n\tmatch l with\n\t|[] -> true\n\t|[x] -> true\n\t|a::b::q when appartient b g.(a) -> chemin_tab (b::q) g\n\t|_ -> false\n;;\n\nchemin_tab [1;2;3] exemple_tab;;\t\n\n(* 4 *)\n\nlet miroir g=\n  let n = Array.length g in\n  let h = Array.make n [] in\n  for i=0 to n-1 do\n    let l = ref [] in\n    for j=0 to n-1 do\n      if List.mem i g.(j) then\n        l:=(i::!l)\n    done;\n    h.(i) <- !l\n  done;\n  h\n;;\n\n(* Entrée : un graphe (S,A) *)\n(* Sortie : le graphe (S,{(y,x) ; (x,y) ∈ A}) *)\n(* \nAm <- {}\n\n(\n∀ (x,y) ∈ A, \n  Rajouter (y,x) dans Am\nRenvoyer (S,Am)\n)\n\nDevient  :\n(\n∀ s ∈ S,                      (1)\n  ∀ t voisin de s,            (2)\n    Rajouter (t,s) dans Am\nRenvoyer (S,Am)\n)\n*)\n\n(* Etude de la complexité de miroir :\nPremiere boucle -> s'execute |S| fois\nDeuxième boucle -> s'execute |S| -1 fois dans le pire cas\n\nComplexité au pire : O(|S|²)\n\nEn plus fin :\nOn prend chaque ligne séparément et on étudie :\n1- Combien de fois elle est executée au total pendant l'execution de l'algo\n2- sa complexité\n\nn<- |S|                                 ->(O(1))\nres <- tab de n cases avec des []       ->(O(n))\n∀ s ∈ S:                                ->(O(n))\n    ∀ t ∈ g.(s)                         \n    res.(t) <- s::res.(t)               ->( ∀ (s,t) ∈ A : O(|A|))\n                                        Donc le cout est |A| * O(1) \n                                        cad O(|A|) sur la boucle\nrenvoyer le resultat                    ->(O(1))\n\nTotal : Σ O(chaque ligne) = O(|S|) + O(|A|)\n*)\n\n(* Remarque : Place mémoire occupée par un graphe :  \n- Matrice d'adj : O(|S|²)\n- tableau de listes d'adj : total O(|S|+|A|) -> on appelle taille du graphe\n  - pour le tab : |S|\n  - pour les listes : |A|\n\n![GrapheExemple]()\n\n\nLe nombre |S|+|A| est appelé \"taille du graphe\"\n    *)\n\nlet miroir2 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  let rec parcoursVoisins s = function     (* (2) *)\n    (* Pour t dans l, on rajoute l'arête (t,s) dans res. Procedure *)\n  | [] -> ()\n  | t::q -> (* t est un sommet accessible depuis s *)\n            res.(t) <- s::(res.(t));\n            parcoursVoisins s q\n  in\n\n  for s=0 to n-1 do\n    parcoursVoisins s (g.(s))\n    done;\n  res\n;;\n\nlet miroir3 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  for s=0 to n-1 do\n    List.iter (fun t -> res.(t) <- s::(res.(t)))\n              g.(s) \n    (* List.iter ne fonctionne que pour les procédures !! *)\n    done;\n  res\n;;\n\n\n\n(* 5 *)\n\n(* \nEntrée : un graphe (S,A)\nSortie : Rien\nEffet de bord : ∀ (s,t) ∈ A, rajoute (t,s) si elle n'y était pas dans A\n\n∀ s ∈ S,                      (1)\n  ∀ t voisin de s,            (2) \n    Si (t,s) n'appartient pas à A        ( List.mem s g.(t)  )\n      Rajouter (t,s) dans A              ( g.(t) <- s::g.(t) )\n*)\n\nlet desoriente g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  let rec parcoursVoisins s = function     (* (2) *)\n    (* Pour t dans l, on rajoute l'arête (t,s) dans res. Procedure *)\n  | [] -> ()\n  | t::q when not(List.mem s g.(t)) ->  g.(t) <- s::g.(t);\n                                        parcoursVoisins s q\n  | t::q -> parcoursVoisins s q\n  in\n\n  for s=0 to n-1 do\n    parcoursVoisins s (g.(s))\n    done;\n  res\n;;\n\nlet desoriente2 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n  \n  for s=0 to n-1 do\n    List.iter (fun t -> if not(List.mem s g.(t)) then \n                          res.(t) <- s::(res.(t)))\n              g.(s) \n    (* List.iter ne fonctionne que pour les procédures !! *)\n    done;\n  res\n;;\n\n(* Pour le 16/11 : faire la 7 et la 8 *)\n(* Indication pour la 8):\nEntrée : Un graphe (S,A)\nSortie : le puits total s'il existe\n\nn= |S|\nnb_aretes_entrantes <- Un tab de n case initialement à 0\n\n∀ s ∈ S:\n    ∀ t voisin de s:\n      Augmenter n_aretes_entrantes.(t) de 1\n\nSi une n-1 est dans nb_aretes_entrantes, alors on verifie que que le sommet est un puis\nc'est alors un puits total sinon non\n\n*)\n\n(* \nSoit un graphe G=(S,G),\nOn suppose que G possède deux puits totaux p1 et p2 tq p1≠p2.\n\nOr p1 est un puits total, alors :\n∀ s ∈ S, p1 est accessible depuis s \n\nEn particulier : p1 est accessible depuis p2\nOr p2 est un puits total alors il ne mène à aucun sommet.\n\nD'où la contradiction. Alors p1=p2.\nUn puits total s'il existe est unique.\n*)\n\nlet aUnPuitsTotal g =\n  let n = Array.length g in\n  let nb_arretes_entrante = Array.make n 0 in\n  let rec voisins s = function\n    | [] -> ()\n    | t::q -> nb_arretes_entrante.(t)<-nb_arretes_entrante.(t)+1;\n              voisins s q\n  in\n  for s=0 to n-1 do\n    voisins s g.(s);\n  done;\n\n  let puits = ref (-1) in\n   for i=0 to n-1 do\n    if nb_arretes_entrante.(i) = n-1 && g.(i)=[] then\n      puits := i;\n   done;\n\n    if !puits <> -1 then\n      (true,!puits)\n    else\n      (false,-1)\n  ;;\n\n\n\n\nlet aUnPuits g=\n  let res = ref false in\n  for i=0 to Array.length g-1 do\n    if g.(i)=[] then\n      res:=true\n  done;\n  !res\n;;\n\naUnPuits exemple_tab;;\n\n\n\n(* Exercice 2 *)\n\n\nlet matrice_of_liste t=\n  let n = Array.length t in\n  let m = Array.make_matrix n n 0 in\n  \n  let rec aux l i m=\n    match l with\n    | [] -> ()\n    | t::q -> m.(i).(t) <- 1; aux q i m;\n  in\n\n  for i=0 to n-1 do\n    aux t.(i) i m\n  done;\n  m\n;;\n\nmatrice_of_liste exemple_tab;;\n    \n\n\nlet liste_of_matrice m=\n  let n = Array.length m in\n  let t = Array.make n [] in\n  for ligne=0 to n-1 do\n    for colonne=0 to n-1 do\n      if m.(ligne).(colonne)=1 then\n        t.(ligne) <- colonne::(t.(ligne))\n    done;\n  done;\n      \n  t\n  ;;\n\nliste_of_matrice exemple_mat;;\n\n(* Exercice 3 *)\n\nlet matriceAleatoire n=\n  let m = Array.make_matrix n n 0 in\n\n  for i=0 to n-1 do\n    for j=0 to n-1 do\n      m.(i).(j)<-Random.int 2\n        \n    done;\n  done;\n  m\n;;\n\nmatriceAleatoire 4;;\n\n\nlet matriceAleatoireNonOriente n=\n  let m = Array.make_matrix n n 0 in\n  for i=0 to n-1 do\n    for j=0 to n-1-i do\n      let r = Random.int 2 in\n      m.(i).(j)<-r;\n      m.(j).(i)<-r;\n    done;\n  done;\n  m\n;;\n\nmatriceAleatoireNonOriente 4;;\n\nlet chemin_entre sd sa g=\n  let n= Array.length g in\n  let chemin = Array.make n [] in \n  let a_Visiter= Queue.create () in\n  let deja_vu= Array.make n false in\n\n  Queue.add sd a_Visiter; \n  chemin.(sd)<-[sd];\n\n  let rec visite_voisins s l=\n    match l with \n    | [] -> ()\n    | t::q when chemin.(t) = []->  Queue.add t a_Visiter;\n                                    chemin.(t)<- t::chemin.(s);\n                                    visite_voisins s q\n    | t::q -> visite_voisins s q\n    in\n  while  not (Queue.is_empty a_Visiter) && chemin.(sa)=[] do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins s g.(s);\n      deja_vu.(s) <- true;\n    )\n\n  done;\n  List.rev chemin.(sa)\n  ;;\n\nlet exemple_tab = [|[1];[2];[3];[0]|];;\n\nlet testTab = [|[1;2];[3;4;5];[6];[4];[];[];[0]|];;\n\nlet pasConnexe = [|[1];[2];[];[4];[]|];;\n\nchemin_entre 0 2 testTab;;\n\nlet plus_court_chemin_entre sd sa g=\n  let n= Array.length g in\n  let chemin = Array.make n [] in \n  let dist = Array.make n (-1) in\n  let a_Visiter= Queue.create () in\n  let deja_vu= Array.make n false in\n\n  Queue.add sd a_Visiter; \n  chemin.(sd)<-[sd];\n\n  let rec visite_voisins s l=\n    match l with \n    | [] -> ()\n    | t::q when dist.(t)=(-1) ->   Queue.add t a_Visiter;\n                                    dist.(t)<- dist.(s)+1;\n                                    chemin.(t)<- t::chemin.(s);\n                                    visite_voisins s q\n    | t::q -> visite_voisins s q\n    in\n  while  not (Queue.is_empty a_Visiter) && chemin.(sa)=[] do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins s g.(s);\n      deja_vu.(s) <- true;\n    )\n\n  done;\n  List.rev chemin.(sa)\n  ;;\n\n(* Pour Lundi 23/11 : Exercice 10*)\n\n(* Exercice 10 *)\n\n(* 1 *)\n\n\n\nlet sphere g s d =\n  let res = ref []\n  and n = Array.length g in\n  for i=0 to n-1 do\n    let dist = (List.length (plus_court_chemin_entre s i g))-1 in\n    if dist = d then\n      res:= i::(!res);\n  done;\n  !res\n;;\n\nlet distanceTab = [|[];[2;3;4];[5;6];[0];[7];[];[];[8];[]|];;\n\nsphere distanceTab 1 2;;\n\nlet boule g s d =\n  let res = ref []\n  and n = Array.length g in\n  for i=0 to n-1 do\n    let dist = (List.length (plus_court_chemin_entre s i g))-1 in\n    if dist <= d then\n      res:= i::(!res);\n  done;\n  !res\n;;\n\nboule distanceTab 1 2;;\n\n\n\n(* Exercice 6 *)\n\nlet composante_connexe g sd=\n  let n= Array.length g in\n  let deja_vu= Array.make n false in\n  let a_Visiter= Queue.create () in\n  Queue.add sd a_Visiter; \n  let rec visite_voisins = function\n    | [] -> ()\n    | t::q -> Queue.add t a_Visiter;\n              visite_voisins q\n  in\n  while  not (Queue.is_empty a_Visiter) do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins g.(s);\n      deja_vu.(s) <- true;\n    )\n  done;\n  (* Maintenant, la composante connexe de sd correspond aux sommetsde deja_vu *)\n  let res = ref [] in\n  for i=0 to n-1 do\n    if deja_vu.(i) then \n      res:= i::(!res)\n  done;\n  !res\n  ;;\n\n\n\nlet composantes_connexes g=\n  let n = Array.length g in\n  let res = ref [] in\n  for s=0 to n-1 do\n    res:=(composante_connexe g s)::!res;\n  done;\n  List.rev !res;\n;;\n\nlet testTab = [|[1;2];[3;4;5];[6];[4];[];[];[0]|];;\n\ncomposantes_connexes testTab;;\n\ncomposante_connexe testTab 1;;\n\n"}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Sending response {"id": 1, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0360012054443ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Sending response {"id": 3, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/setTraceNotification","params":{"value":"off"}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":false,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true}}}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0209808349609ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0131130218506ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 7, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.018835067749ms
Sending response {"id": 8, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 9, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0200271606445ms
Sending response {"id": 10, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"},"range":{"start":{"line":540,"character":7},"end":{"line":540,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0379085540771ms
Sending response {"id": 11, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml","version":1},"contentChanges":[{"text":"(* exercice 1 *)\n\ntype graphe1 = int array array;;\ntype graphe2 = int list array;; \n\nlet exemple_mat = [|  [|0;1;0;0|];\n                      [|0;0;1;0|];\n                      [|0;0;0;1|];\n                      [|1;0;0;0|]\n|];;\n\nlet exemple_tab = [|[1];[2];[3];[0]|];;\n\n(* Exercice 1 *)\n\n(* 1 *)\n\nlet compte_Matrice m=\n  let res = ref 0 in\n  for i=0 to Array.length m-1 do\n    for j=0 to Array.length m-1 do\n      if m.(i).(j) = 1 then\n        res:=!res+1\n    done;\n  done;\n  !res\n;;\n\ncompte_Matrice exemple_mat;;\n\nlet compte_liste t=\n  let res=ref 0 in\n  for i=0 to Array.length t-1 do\n    res:=!res+ List.length t.(i)\n  done;\n  !res\n;;\n\ncompte_liste exemple_tab;;\n\n\n(* Pour Samedi : questions 2,3 *)\n\n(* 2 *)\nlet tableau_i n i=\n\tlet res = Array.make n 1 in\n\tfor j = 0 to n-1 do\n\t\tif i=j then\n\t\t\tres.(j) <- 0\n  done;\n  res\n;;\n\t\nlet clique_mat n=\n\tlet res = Array.make n [||] in\n\tfor i=0 to n-1 do\n\t\tres.(i) <- tableau_i n i\n\tdone;\n\tres\n;;\n\nclique_mat 2;;\n\n\t\nlet rec liste_sans_i i n=\n\tmatch n with\n\t|0 -> []\n\t|t when i <> t -> t::(liste_sans_i i (t-1))\n\t|t -> liste_sans_i i (t-1)\n;;\n\t\nlet rec clique_tab n=\n\tlet res = (Array.make n [] ) in\n\tfor i=0 to n-1 do\n\t\tres.(i) <- liste_sans_i (i+1) n\n\tdone;\n\tres\n;;\n\nclique_tab 4;;\t\n\t\n\t\n(* 3 *)\nlet chemin_mat l g=\n\tlet res = ref true in\n\tfor i=0 to Array.length l -2 do\n\t\tif g.(l.(i)).(l.(i+1)) = 0 then\n\t\t\tres := false\n\tdone;\n\t!res\n;;\n\nchemin_mat [|1;2;3|] exemple_mat;;\n\nlet rec appartient x l=\n\tmatch l with\n\t|[] -> false\n\t|t::q when t = x -> true\n\t|t::q -> appartient x q\n;;\n\nlet rec chemin_tab l g=\n\tmatch l with\n\t|[] -> true\n\t|[x] -> true\n\t|a::b::q when appartient b g.(a) -> chemin_tab (b::q) g\n\t|_ -> false\n;;\n\nchemin_tab [1;2;3] exemple_tab;;\t\n\n(* 4 *)\n\nlet miroir g=\n  let n = Array.length g in\n  let h = Array.make n [] in\n  for i=0 to n-1 do\n    let l = ref [] in\n    for j=0 to n-1 do\n      if List.mem i g.(j) then\n        l:=(i::!l)\n    done;\n    h.(i) <- !l\n  done;\n  h\n;;\n\n(* Entrée : un graphe (S,A) *)\n(* Sortie : le graphe (S,{(y,x) ; (x,y) ∈ A}) *)\n(* \nAm <- {}\n\n(\n∀ (x,y) ∈ A, \n  Rajouter (y,x) dans Am\nRenvoyer (S,Am)\n)\n\nDevient  :\n(\n∀ s ∈ S,                      (1)\n  ∀ t voisin de s,            (2)\n    Rajouter (t,s) dans Am\nRenvoyer (S,Am)\n)\n*)\n\n(* Etude de la complexité de miroir :\nPremiere boucle -> s'execute |S| fois\nDeuxième boucle -> s'execute |S| -1 fois dans le pire cas\n\nComplexité au pire : O(|S|²)\n\nEn plus fin :\nOn prend chaque ligne séparément et on étudie :\n1- Combien de fois elle est executée au total pendant l'execution de l'algo\n2- sa complexité\n\nn<- |S|                                 ->(O(1))\nres <- tab de n cases avec des []       ->(O(n))\n∀ s ∈ S:                                ->(O(n))\n    ∀ t ∈ g.(s)                         \n    res.(t) <- s::res.(t)               ->( ∀ (s,t) ∈ A : O(|A|))\n                                        Donc le cout est |A| * O(1) \n                                        cad O(|A|) sur la boucle\nrenvoyer le resultat                    ->(O(1))\n\nTotal : Σ O(chaque ligne) = O(|S|) + O(|A|)\n*)\n\n(* Remarque : Place mémoire occupée par un graphe :  \n- Matrice d'adj : O(|S|²)\n- tableau de listes d'adj : total O(|S|+|A|) -> on appelle taille du graphe\n  - pour le tab : |S|\n  - pour les listes : |A|\n\n![GrapheExemple]()\n\n\nLe nombre |S|+|A| est appelé \"taille du graphe\"\n    *)\n\nlet miroir2 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  let rec parcoursVoisins s = function     (* (2) *)\n    (* Pour t dans l, on rajoute l'arête (t,s) dans res. Procedure *)\n  | [] -> ()\n  | t::q -> (* t est un sommet accessible depuis s *)\n            res.(t) <- s::(res.(t));\n            parcoursVoisins s q\n  in\n\n  for s=0 to n-1 do\n    parcoursVoisins s (g.(s))\n    done;\n  res\n;;\n\nlet miroir3 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  for s=0 to n-1 do\n    List.iter (fun t -> res.(t) <- s::(res.(t)))\n              g.(s) \n    (* List.iter ne fonctionne que pour les procédures !! *)\n    done;\n  res\n;;\n\n\n\n(* 5 *)\n\n(* \nEntrée : un graphe (S,A)\nSortie : Rien\nEffet de bord : ∀ (s,t) ∈ A, rajoute (t,s) si elle n'y était pas dans A\n\n∀ s ∈ S,                      (1)\n  ∀ t voisin de s,            (2) \n    Si (t,s) n'appartient pas à A        ( List.mem s g.(t)  )\n      Rajouter (t,s) dans A              ( g.(t) <- s::g.(t) )\n*)\n\nlet desoriente g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n\n  let rec parcoursVoisins s = function     (* (2) *)\n    (* Pour t dans l, on rajoute l'arête (t,s) dans res. Procedure *)\n  | [] -> ()\n  | t::q when not(List.mem s g.(t)) ->  g.(t) <- s::g.(t);\n                                        parcoursVoisins s q\n  | t::q -> parcoursVoisins s q\n  in\n\n  for s=0 to n-1 do\n    parcoursVoisins s (g.(s))\n    done;\n  res\n;;\n\nlet desoriente2 g=\n  let n = Array.length g in \n  let res = (Array.make n []) in\n  \n  for s=0 to n-1 do\n    List.iter (fun t -> if not(List.mem s g.(t)) then \n                          res.(t) <- s::(res.(t)))\n              g.(s) \n    (* List.iter ne fonctionne que pour les procédures !! *)\n    done;\n  res\n;;\n\n(* Pour le 16/11 : faire la 7 et la 8 *)\n(* Indication pour la 8):\nEntrée : Un graphe (S,A)\nSortie : le puits total s'il existe\n\nn= |S|\nnb_aretes_entrantes <- Un tab de n case initialement à 0\n\n∀ s ∈ S:\n    ∀ t voisin de s:\n      Augmenter n_aretes_entrantes.(t) de 1\n\nSi une n-1 est dans nb_aretes_entrantes, alors on verifie que que le sommet est un puis\nc'est alors un puits total sinon non\n\n*)\n\n(* \nSoit un graphe G=(S,G),\nOn suppose que G possède deux puits totaux p1 et p2 tq p1≠p2.\n\nOr p1 est un puits total, alors :\n∀ s ∈ S, p1 est accessible depuis s \n\nEn particulier : p1 est accessible depuis p2\nOr p2 est un puits total alors il ne mène à aucun sommet.\n\nD'où la contradiction. Alors p1=p2.\nUn puits total s'il existe est unique.\n*)\n\nlet aUnPuitsTotal g =\n  let n = Array.length g in\n  let nb_arretes_entrante = Array.make n 0 in\n  let rec voisins s = function\n    | [] -> ()\n    | t::q -> nb_arretes_entrante.(t)<-nb_arretes_entrante.(t)+1;\n              voisins s q\n  in\n  for s=0 to n-1 do\n    voisins s g.(s);\n  done;\n\n  let puits = ref (-1) in\n   for i=0 to n-1 do\n    if nb_arretes_entrante.(i) = n-1 && g.(i)=[] then\n      puits := i;\n   done;\n\n    if !puits <> -1 then\n      (true,!puits)\n    else\n      (false,-1)\n  ;;\n\n\n\n\nlet aUnPuits g=\n  let res = ref false in\n  for i=0 to Array.length g-1 do\n    if g.(i)=[] then\n      res:=true\n  done;\n  !res\n;;\n\naUnPuits exemple_tab;;\n\n\n\n(* Exercice 2 *)\n\n\nlet matrice_of_liste t=\n  let n = Array.length t in\n  let m = Array.make_matrix n n 0 in\n  \n  let rec aux l i m=\n    match l with\n    | [] -> ()\n    | t::q -> m.(i).(t) <- 1; aux q i m;\n  in\n\n  for i=0 to n-1 do\n    aux t.(i) i m\n  done;\n  m\n;;\n\nmatrice_of_liste exemple_tab;;\n    \n\n\nlet liste_of_matrice m=\n  let n = Array.length m in\n  let t = Array.make n [] in\n  for ligne=0 to n-1 do\n    for colonne=0 to n-1 do\n      if m.(ligne).(colonne)=1 then\n        t.(ligne) <- colonne::(t.(ligne))\n    done;\n  done;\n      \n  t\n  ;;\n\nliste_of_matrice exemple_mat;;\n\n(* Exercice 3 *)\n\nlet matriceAleatoire n=\n  let m = Array.make_matrix n n 0 in\n\n  for i=0 to n-1 do\n    for j=0 to n-1 do\n      m.(i).(j)<-Random.int 2\n        \n    done;\n  done;\n  m\n;;\n\nmatriceAleatoire 4;;\n\n\nlet matriceAleatoireNonOriente n=\n  let m = Array.make_matrix n n 0 in\n  for i=0 to n-1 do\n    for j=0 to n-1-i do\n      let r = Random.int 2 in\n      m.(i).(j)<-r;\n      m.(j).(i)<-r;\n    done;\n  done;\n  m\n;;\n\nmatriceAleatoireNonOriente 4;;\n\nlet chemin_entre sd sa g=\n  let n= Array.length g in\n  let chemin = Array.make n [] in \n  let a_Visiter= Queue.create () in\n  let deja_vu= Array.make n false in\n\n  Queue.add sd a_Visiter; \n  chemin.(sd)<-[sd];\n\n  let rec visite_voisins s l=\n    match l with \n    | [] -> ()\n    | t::q when chemin.(t) = []->  Queue.add t a_Visiter;\n                                    chemin.(t)<- t::chemin.(s);\n                                    visite_voisins s q\n    | t::q -> visite_voisins s q\n    in\n  while  not (Queue.is_empty a_Visiter) && chemin.(sa)=[] do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins s g.(s);\n      deja_vu.(s) <- true;\n    )\n\n  done;\n  List.rev chemin.(sa)\n  ;;\n\nlet exemple_tab = [|[1];[2];[3];[0]|];;\n\nlet testTab = [|[1;2];[3;4;5];[6];[4];[];[];[0]|];;\n\nlet pasConnexe = [|[1];[2];[];[4];[]|];;\n\nchemin_entre 0 2 testTab;;\n\nlet plus_court_chemin_entre sd sa g=\n  let n= Array.length g in\n  let chemin = Array.make n [] in \n  let dist = Array.make n (-1) in\n  let a_Visiter= Queue.create () in\n  let deja_vu= Array.make n false in\n\n  Queue.add sd a_Visiter; \n  chemin.(sd)<-[sd];\n\n  let rec visite_voisins s l=\n    match l with \n    | [] -> ()\n    | t::q when dist.(t)=(-1) ->   Queue.add t a_Visiter;\n                                    dist.(t)<- dist.(s)+1;\n                                    chemin.(t)<- t::chemin.(s);\n                                    visite_voisins s q\n    | t::q -> visite_voisins s q\n    in\n  while  not (Queue.is_empty a_Visiter) && chemin.(sa)=[] do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins s g.(s);\n      deja_vu.(s) <- true;\n    )\n\n  done;\n  List.rev chemin.(sa)\n  ;;\n\n(* Pour Lundi 23/11 : Exercice 10*)\n\n(* Exercice 10 *)\n\n(* 1 *)\n\n\n\nlet sphere g s d =\n  let res = ref []\n  and n = Array.length g in\n  for i=0 to n-1 do\n    let dist = (List.length (plus_court_chemin_entre s i g))-1 in\n    if dist = d then\n      res:= i::(!res);\n  done;\n  !res\n;;\n\nlet distanceTab = [|[];[2;3;4];[5;6];[0];[7];[];[];[8];[]|];;\n\nsphere distanceTab 1 2;;\n\nlet boule g s d =\n  let res = ref []\n  and n = Array.length g in\n  for i=0 to n-1 do\n    let dist = (List.length (plus_court_chemin_entre s i g))-1 in\n    if dist <= d then\n      res:= i::(!res);\n  done;\n  !res\n;;\n\nboule distanceTab 1 2;;\n\n\n\n(* Exercice 6 *)\n\nlet composante_connexe g sd=\n  let n= Array.length g in\n  let deja_vu= Array.make n false in\n  let a_Visiter= Queue.create () in\n  Queue.add sd a_Visiter; \n  let rec visite_voisins = function\n    | [] -> ()\n    | t::q -> Queue.add t a_Visiter;\n              visite_voisins q\n  in\n  while  not (Queue.is_empty a_Visiter) do\n    let s= Queue.take a_Visiter in\n    if not (deja_vu.(s)) then\n    (\n      visite_voisins g.(s);\n      deja_vu.(s) <- true;\n    )\n  done;\n  (* Maintenant, la composante connexe de sd correspond aux sommetsde deja_vu *)\n  let res = ref [] in\n  for i=0 to n-1 do\n    if deja_vu.(i) then \n      res:= i::(!res)\n  done;\n  !res\n  ;;\n\n\n\nlet composantes_connexes g=\n  let n = Array.length g in\n  let res = ref [] in\n  for s=0 to n-1 do\n    res:=(composante_connexe g s)::!res;\n  done;\n  List.rev !res;\n;;\n\nlet testTab = [|[1;2];[3;4;5];[6];[4];[];[];[0]|];;\n\ncomposantes_connexes testTab;;\n\ncomposante_connexe testTab 1;;\n\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml","version":1}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0350475311279ms
Sending response {"id": 12, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///mnt/c/Users/leosa/Desktop/INFO/CPGE/MP/SPE/Chap4_Graphes.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Sending response {"id": 13, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
