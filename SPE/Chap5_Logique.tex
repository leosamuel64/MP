\newtheorem{rmq}{Remarque}
\newtheorem{defi}{Définition}
\begin{document}
\maketitle

\section{Calcul booléen}

\subsection{Notations}

\begin{itemize}
    \item Vrai : $\top$
    \item Faux : $\bot$
    \item Non : $\lnot$
    \item Et : $\land$
    \item Ou : $\lor$
\end{itemize}

De plus, dans ce chapitre, on notera $\mathcal{B}=\{\top,\bot\}$ \\
L'ordre de priorité dans les calculs sera : $\lnot$,$\land$,$\lor$ \\

\subsection{Règles de calcul}

\begin{prop}
    $\land$ :
    \begin{itemize}
        \item Commutatif
        \item Associatif
        \item Neutre : $\top$
    \end{itemize}
\end{prop}

\begin{prop}
    $\lor$ :
    \begin{itemize}
        \item Commutatif
        \item Associatif
        \item Neutre : $\bot$
    \end{itemize}
\end{prop}

\begin{prop}
    Entre $\lor$, $\land$ et $\lnot$
    \begin{itemize}
        \item Distributivité ($\lor$ est distributif sur $\land$ et inversement contrairement aux nombres)
        \item Loi de De Morgan : $\forall (a,b,c) \in \mathcal{B}^3$
            \begin{itemize}
                \item $\lnot(a\land b)= \lnot a \lor \lnot b$
                \item $\lnot(a\lor b)= \lnot a \land \lnot b$
            \end{itemize}
    \end{itemize}
\end{prop}

\begin{dem}
    Montrons que $\forall (a,b,c) \in \mathcal{B}^3, a\land(b\lor c)=(a\land b)\lor (a \land c)$ \\
    On étudie toutes les possibilités pour ($(a,b,c))$. Il y en a $8$ car $2^3=8$ \\
    On les regroupes dans une table de vérité \\

        \begin{tabular}{|l|l|l|l|l|l|l|l|}
        \hline
        $a$ & $b$ & $c$ & $b\lor c$ & $a\land (b\lor c$ & $a\land b$ & $a \land c$ & $(a\land b)\lor (a\land c)$ \\ \hline
        0   & 0   & 0   & 0         & 0                 & 0          & 0           & 0                           \\ \hline
        0   & 0   & 1   & 1         & 0                 & 0          & 0           & 0                           \\ \hline
        0   & 1   & 0   & 1         & 0                 & 0          & 0           & 0                           \\ \hline
        0   & 1   & 1   & 1         & 0                 & 0          & 0           & 0                           \\ \hline
        1   & 0   & 0   & 0         & 0                 & 0          & 0           & 0                           \\ \hline
        1   & 0   & 1   & 1         & 1                 & 0          & 1           & 1                           \\ \hline
        1   & 1   & 0   & 1         & 1                 & 1          & 0           & 1                           \\ \hline
        1   & 1   & 1   & 1         & 1                 & 1          & 1           & 1                            \\ \hline
        \end{tabular}


    Les colonnes sont identiques \\
\end{dem}

Les propriétés de $\land$ et $\lor$ ressemblent à celle pour $\cdot$ et $+$ sur $\mathbb{Z}/n\mathbb{Z}$ \\

On utilise alors souvent : 
\begin{itemize}
    \item $0$
    \item $1$
    \item $\cdot$
    \item $+$
\end{itemize}

Attention dans ce cas, $1+1=1$

Dans ce cas, les lois de De Morgan sont :
\begin{th}
Loi de De Morgan : $\forall (a,b,c) \in \mathcal{B}^3$
\begin{itemize}
    \item $\overline{(a\land b)}= \overline a + \overline b$
    \item $\overline{(a + b)}= \overline a  \overline b$
\end{itemize}
\end{th}



\begin{rmq}
    $(\mathbb{Z}/n\mathbb{Z},+,\cdot)$ est un corps. \\
    $(B,\lor,\land)$ n'est même pas un anneau car $1$ n'a pas d'opposé
\end{rmq}

\begin{rmq}
    Notons $\oplus$ le ou exclusif : \\
    $1\oplus 1=0$
    On peut vérifier que $(B,\oplus,\land)$ est un corps , isomorphe à $\mathbb{Z}/n\mathbb{Z}$
\end{rmq}

\subsection{Autres connecteurs logiques}
Combien y-a-t-il de fonction de $\mathcal{B}$ dans $\mathcal{B}$ ? \\
Il y en a $|\mathcal{B}|^{|\mathcal{B}|}=4$ \\
Il y a $id,\lnot,0,1$ \\

Combien y-a-t-il de fonction de $\mathcal{B}^2$ dans $\mathcal{B}$ ?
Il y en a 16. Nous connaisons déja $\lor,\land,\lxor$

Pour definir un opérateur, il suffit de donnée sa table de vérité

\subsubsection{L'implication}
\begin{defi}
    $\forall a,b \in \mathcal{B}$, on note $a\Rightarrow b$ le booléen $b\lor\lnot a$
\end{defi}

\begin{ex}
    "Mange ta soupe ou va dans ta chambre"  \copyright FP\\
    donne \\
    "Si tu ne mange pas ta soupe alors va dans ta chambre"\\
\end{ex}

Interpretation en mathématiques :\\
Table de vérité de $\Rightarrow$ :

    \begin{tabular}{|l|l|l|} 
    \hline
    $a$ & $b$ & $a\Rightarrow b$ \\ \hline
    0   & 0   & 1                \\ \hline
    0   & 1   & 1                \\ \hline
    1   & 0   & 0                \\ \hline
    1   & 1   & 1     \\ \hline          
    \end{tabular}


Ainsi, la formule $\forall (a,b) \in \mathcal{B}^2, a \Rightarrow b$ est vraie si et seulement si a chaque fois que a est vrai, b l'est aussi. (Quand a est faux, b peut valoir n'importe quoi !)

Digressions : \\
Un théorème est une formule $\forall x \in E, P(x) \Rightarrow Q(x)$ où $E$ est un ensemble et $P,Q$ des prédicats sur $E$. (fonctions de $E$ dans $\mathcal{B}$)
Dans le cas où $P$ est faux, on a aucune informations sur $Q$. 

Pour montrer q'un théorème est faux, il faut montrer
$\lnot(\forall x \in E, P(x) \Rightarrow Q(x))$ cad $\exists x \in E, \lnot(P(x) \Rightarrow Q(x))$ cad $\exists x \in E, \lnot Q(x) \land P(x)$
Ainsi, cela revient à trouver un $x\in E$ pour lequel l'hypothèse est vraie mais la conclusion est fausse. Un tel $x$ s'appelle un contre-exemple

\subsubsection{Equivalents}
\begin{defi}
    $\forall (a,b) \in \mathcal{B}^2$, on note $a<\Rightarrowb$ le booléen $(a\Rightarrow b) \land (b\Rightarrow a)$
    C'est en réalité la même chose que $=$ pour les booléens
\end{defi}

\subsubsection{Non-et}
\begin{defi}
    $\forall (a,b) \in \mathcal{B}^2,\lnot(a\land b)$ 
\end{defi}

Il est utilisé car il coute seulement 3 transistors. \\
On peut definir les autres opérations à partir du non-et. (cf Exercice 9) \\

De même on définit non-ou.\\

En général dans un langage, il est seulement fournit $\lnot,\land,\lor$ desquels on peut définir les autres.


\section{Formules logiques}

\subsection{Type Caml}

Voici un type pour représenter les formules logiques :

\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=white,
    fontsize=\footnotesize,
    linenos]
    {ocaml}
type formule =
  | Variable of string
  | Non of formule
  | Et of (formule*formule)
  | Ou of (formule*formule)
  | Constante of bool
    ;;

    \end{minted}

    Ainsi l'exemple $\overline{a+b}\cdot c$ par :


\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=white,
    fontsize=\footnotesize,
    linenos]
    {ocaml}
let exemple 1 = Et(Non(Ou(Variable "a",Variable "b")),Variable "c");;
    \end{minted}

Ce type est similaire à un type arbre.

\subsection{Définition Mathématique}

On définit le concept de formule abstraite.\\
Soit $\Sigma$ un ensemble dont les éléments seront appelés des "variable (booléenes)". On définit alors l'ensemble des formules logiques ainsi :\\

\begin{itemize}
    \item $\forall x \in \Sigma,x$ est une formule
    \item $\forall b \in B,b$ est une formule
    \item $\forall$ formule $f, \overline{f}$ est une formule
    \item $\forall$ formule $f_1,f_2, f_1+f_2$ et $f_1f_2$ sont des formules
\end{itemize}

\begin{ex}\\
    Soit $a,b,c \in B$\\
    $\overline{(a+b)}c$ est une formule\\
    $\lor \lor a$ n'est pas une formule\\
\end{ex} 

\subsection{Sémantique}

Donnons un sens aux formules abstraites définies ci-dessus.\\

En pratique, on va définir des fonctions qui utilisent ces formules

\begin{defi}
    Un contexte (ou distribution de vérité ou valuation) sur $\Sigma$ est une fonction de $\Sigma$ dans $B$.\\
\end{defi}

Choisir un contexte sur $\Sigma$ revient à choisir la valeur de chaque variable.

\begin{defi}
    Soit $\varphi$ un contexte sur $\Sigma$. Notons $\mathcal{F}$ l'ensemble des formule sur $\Sigma$.\\

    On définit la fonction "Evaluation en $\varphi$", qu'on note $E_v_{\varphi}$\\
    Ainsi:\\
    $\forall b \ in B, E_v_{\varphi}(b)=b$ \\
    $\forall x \ in \Sigma, E_v_{\varphi}(x)=\varphi(x)$ \\
    $\forall f in \mathcal{F},E_v_{\varphi}(\lnot f)=\lnot E_v_{\varphi}(f)$ \\
    $\forall f_1,f_2 in \mathcal{F},E_v_{\varphi}(f_1f_2)= E_v_{\varphi}(f_1)E_v_{\varphi}(f_2)$ \\
    $\forall f_1,f_2 in \mathcal{F},E_v_{\varphi}(f_1+f_2)= E_v_{\varphi}(f_1)+E_v_{\varphi}(f_2)$ \\
\end{defi}

Pour représenter un contexte en Ocaml, utilisons un dictionnaire. Pour des exemples avec peu de variables, utilisons les listes d'association.\\

\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=white,
    fontsize=\footnotesize,
    linenos]
    {ocaml}
type contexte = (string * bool) list;;
    \end{minted}

La fonction d'évaluation devient alors : \\ 

\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=white,
    fontsize=\footnotesize,
    linenos]
    {ocaml}
let rec evaluation contexte formule=
	match formule with
	| Constante b -> b
	| Variable x -> List.assoc x contexte
	| Non f ->not (evaluation contexte f)
	| Ou (f1,f2) -> (evaluation contexte f1) || (evaluation contexte f2)
	| Et (f1,f2) -> (evaluation contexte f1) && (evaluation contexte f2)
;;
    \end{minted}

\subsection{Vocabulaire}

Notons toujours $\mathcal{F}$ l'ensemble des formules. Notons $\mathcal{C}$ l'ensemble des contextes sur $\Sigma$

\begin{defi}
    Soit $f \in \mathcal{F}$
    \begin{itemize}
        \item On dit que $f$ est satisfiable lorsque $\exists \varphi \in \mathcal{C} tq E_v_{\varphi}(f)=\top$
        \item On dit que $f$ est tautologique lorsque $\forall \varphi \in \mathcal{C} tq E_v_{\varphi}(f)=\top$
        \item Soit $g \in mathcal{F}$. On dit que $f$ est équivalente à $g$ ($f\equiv g$) lorsque $E_v_{\varphi}(f)=E_v_{\varphi}(g)$
    \end{itemize}
\end{defi}

Ecrivons une fonction qui teste si une formule est satisfiable :\\

Méthode naive : calculons la liste de tous les contextes :

\begin{minted}[
    frame=lines,
    framesep=2mm,
    baselinestretch=1.2,
    bgcolor=white,
    fontsize=\footnotesize,
    linenos]
    {ocaml}
let rec listeVariables formule=
	match formule with
	| Constante b -> []
	| Variable x -> [x]
	| Non f -> listeVariables f
	| Ou (f1,f2) -> fusion_stricte (listeVariables f1) (listeVariables f2)
	| Et (f1,f2) -> fusion_stricte (listeVariables f1) (listeVariables f2)
;;
  
let rec listeContexte listeVariables=
	match listeVariables with
	| [] -> [[]]
	| t::q -> (List.map (fun x -> (t,false)::x) (listeContexte q))
						@
						(List.map (fun x -> (t,true)::x) (listeContexte q))
;;

let estSatisfiable formule=
	let variables = listeVariables formule in
	let contextes = listeContexte variables in
	
	let rec aux contexte =
		match contexte with
		| [] -> false
		| t::q -> (evaluation t formule) || aux q
	in
	aux contextes
;;

let estTautologique formule=
	let variables = listeVariables formule in
	let contextes = listeContexte variables in
	
	let rec aux contexte =
		match contexte with
		| [] -> true
		| t::q -> (evaluation t formule) && aux q
	in
	aux contextes
;;

let plusLongue l1 l2=
  let a, b = List.length l1,List.length l2 in
  if a > b then
    l1
  else l2
;;

let sontEquivalentes f g=
  let variablesf = listeVariables f in
  let variablesg = listeVariables g in
  
  let contextes = listeContexte (plusLongue variablesf variablesg) in

  let rec aux contexte =
    match contexte with
    | [] -> true
    | t::q -> ((evaluation t f)=(evaluation t g)) && (aux q)
  in
  aux contextes
;;
    \end{minted}











\subsection{Formes normales}

\begin{itemize}
    \item Un minterme est vrai pour un seul contexte ($a\overline{b}c$ est vrai pour ${1,0,1}$)
    \item Un maxterme est faux pour un et un seul contexte ($\overline a + \overline b + c$ est faux pour ${1,1,0}$)
    \item La négation d'un minterme est un maxterme et réciproquement.
    \item La forme normale disjonctive revient à la table de vérité de la formule
\end{itemize}

\begin{ex}
    Soit $f=\overline{a\Rightarrow b} \lor c$\\
    On a $f\equiv \overline{b}a+c$ \\
    Ce n'est pas encore la forme normale car les deux monomes n'utilisent pas toutes les variables.\\

    $f\equiv a\overline{b}c+a\overline{b}\overline{c}+abc+\overline{a}bc+\overline{a}\overline{b}c$ \\
    Somme de cinq mintermes alors c'est une somme normale disjonctive\\
    Chaque monomes indique un contexte où $f$ est vraie, autrement dit une ligne de la table de vérité\\
\end{ex}

\begin{itemize}
    \item Le nombre de mintermes dans la formes normale disjonctive est le nombre de contextes où $f$ est vraie
    \item Si on connait la table de vérité, on peutr retrouver la forme normale disjonctive
    \item Une forme normale disjonctive est unique
    \item Mettre deux formules $f$ et $g$ sous forme normale disjonctive est une méthode infaillble pour savoir si $f\equiv g$
    \item Idem pour voir si $f$ est une tautologie ou satisfiable ...
    \item La négation d'une forme normale disjonctive est un forme normale conjonctive
    \item On peut alors partir d'une forme normale disjonctive de $f$ pour obtenir une forme normale conjonctive de $\overline f$
    \item On part de la forme normale disjonctive de $\overline f$ pour avoir une forme normale conjonctif de $f$
    \item Chaque maxterme s'appelle une clause
    \item Le nombre de maxterme est le nombre de contexte ou f est fausse ($\bot$)
\end{itemize}

\section{Problème NP-complets}

Ces fonctions permettent de résoudre de nombreux problemes


Mais leurs complexités est supérieurs à $2^n$\\

On n'a jamais découvert d'algorithme de complexité polynomial. Ce problème s'appelle "SAT"

Deux problèmes sont équivalent si l'existence d'un algo de complexité polynomial pour l'un entraine l'existence d'un algo de complexité pour l'autre.\\

Tout problème équivalent à SAT est appelé "NP-Complet" (cf exercice 12)
















\end{document}